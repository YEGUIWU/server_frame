!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
LexicalCast	test_config.cc	/^    class LexicalCast<Person, std::string> {$/;"	c	namespace:ygw::config	file:
LexicalCast	test_config.cc	/^    class LexicalCast<std::string, Person> {$/;"	c	namespace:ygw::config	file:
Person	test_config.cc	/^    Person() $/;"	f	class:Person	access:public	signature:()
Person	test_config.cc	/^class Person {$/;"	c	file:
Person::Person	test_config.cc	/^    Person() $/;"	f	class:Person	access:public	signature:()
Person::ToString	test_config.cc	/^    std::string ToString() const $/;"	f	class:Person	access:public	signature:() const
Person::age_	test_config.cc	/^    int age_ = 0;$/;"	m	class:Person	file:	access:public
Person::name_	test_config.cc	/^    std::string name_;$/;"	m	class:Person	file:	access:public
Person::operator ==	test_config.cc	/^    bool operator==(const Person& oth) const $/;"	f	class:Person	access:public	signature:(const Person& oth) const
Person::sex_	test_config.cc	/^    bool sex_ = 0;$/;"	m	class:Person	file:	access:public
ToString	test_config.cc	/^    std::string ToString() const $/;"	f	class:Person	access:public	signature:() const
XX	test_config.cc	124;"	d	file:
XX	test_config.cc	86;"	d	file:
XX_PM	test_config.cc	202;"	d	file:
XX_PM	test_config.cc	225;"	d	file:
YY	test_config.cc	123;"	d	file:
YY	test_config.cc	95;"	d	file:
age_	test_config.cc	/^    int age_ = 0;$/;"	m	class:Person	file:	access:public
config	test_config.cc	/^    namespace config {$/;"	n	namespace:ygw	file:
func1	test_thread.cc	/^void func1()$/;"	f	signature:()
func2	test_thread.cc	/^void func2()$/;"	f	signature:()
func3	test_thread.cc	/^void func3()$/;"	f	signature:()
g_count	test_thread.cc	/^int g_count = 0;$/;"	v
g_float_value_config	test_config.cc	/^ygw::config::ConfigVar<float>::ptr g_float_value_config =$/;"	v
g_int_lst_value_config	test_config.cc	/^ygw::config::ConfigVar<std::list<int>>::ptr g_int_lst_value_config =$/;"	v
g_int_map_value_config	test_config.cc	/^ygw::config::ConfigVar<std::map<std::string, int>>::ptr g_int_map_value_config =$/;"	v
g_int_set_value_config	test_config.cc	/^ygw::config::ConfigVar<std::set<int>>::ptr g_int_set_value_config =$/;"	v
g_int_umap_value_config	test_config.cc	/^ygw::config::ConfigVar<std::unordered_map<std::string, int>>::ptr g_int_umap_value_config =$/;"	v
g_int_uset_value_config	test_config.cc	/^ygw::config::ConfigVar<std::unordered_set<int>>::ptr g_int_uset_value_config =$/;"	v
g_int_value_config	test_config.cc	/^ygw::config::ConfigVar<int>::ptr g_int_value_config =$/;"	v
g_int_vec_value_config	test_config.cc	/^ygw::config::ConfigVar<std::vector<int>>::ptr g_int_vec_value_config =$/;"	v
g_logger	test_fiber.cc	/^ygw::log::Logger g_logger =  YGW_LOG_ROOT();$/;"	v
g_logger	test_thread.cc	/^ygw::log::Logger::ptr g_logger = YGW_LOG_ROOT();$/;"	v
g_logger	test_util.cc	/^ygw::log::Logger::ptr g_logger = YGW_LOG_ROOT();$/;"	v
g_person_map	test_config.cc	/^ygw::config::ConfigVar<std::map<std::string, Person> >::ptr g_person_map =$/;"	v
g_person_vec_map	test_config.cc	/^ygw::config::ConfigVar<std::map<std::string, std::vector<Person> > >::ptr g_person_vec_map =$/;"	v
main	test_config.cc	/^int main()$/;"	f	signature:()
main	test_fiber.cc	/^int main()$/;"	f	signature:()
main	test_log.cc	/^int main()$/;"	f	signature:()
main	test_thread.cc	/^int main()$/;"	f	signature:()
main	test_util.cc	/^int main()$/;"	f	signature:()
name_	test_config.cc	/^    std::string name_;$/;"	m	class:Person	file:	access:public
operator ()	test_config.cc	/^        Person operator()(const std::string& v) {$/;"	f	class:ygw::config::LexicalCast	access:public	signature:(const std::string& v)
operator ()	test_config.cc	/^        std::string operator()(const Person& p) {$/;"	f	class:ygw::config::LexicalCast	access:public	signature:(const Person& p)
operator ==	test_config.cc	/^    bool operator==(const Person& oth) const $/;"	f	class:Person	access:public	signature:(const Person& oth) const
print_yaml	test_config.cc	/^void print_yaml(const YAML::Node& node, int level)$/;"	f	signature:(const YAML::Node& node, int level)
run_in_fiber	test_fiber.cc	/^void run_in_fiber()$/;"	f	signature:()
sex_	test_config.cc	/^    bool sex_ = 0;$/;"	m	class:Person	file:	access:public
test_assert	test_util.cc	/^void test_assert() $/;"	f	signature:()
test_class	test_config.cc	/^void test_class()$/;"	f	signature:()
test_config	test_config.cc	/^void test_config() $/;"	f	signature:()
test_log	test_config.cc	/^void test_log()$/;"	f	signature:()
test_yaml	test_config.cc	/^void test_yaml()$/;"	f	signature:()
ygw	test_config.cc	/^namespace ygw{$/;"	n	file:
ygw::config	test_config.cc	/^    namespace config {$/;"	n	namespace:ygw	file:
ygw::config::LexicalCast	test_config.cc	/^    class LexicalCast<Person, std::string> {$/;"	c	namespace:ygw::config	file:
ygw::config::LexicalCast	test_config.cc	/^    class LexicalCast<std::string, Person> {$/;"	c	namespace:ygw::config	file:
ygw::config::LexicalCast::operator ()	test_config.cc	/^        Person operator()(const std::string& v) {$/;"	f	class:ygw::config::LexicalCast	access:public	signature:(const std::string& v)
ygw::config::LexicalCast::operator ()	test_config.cc	/^        std::string operator()(const Person& p) {$/;"	f	class:ygw::config::LexicalCast	access:public	signature:(const Person& p)
